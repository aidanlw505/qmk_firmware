#include QMK_KEYBOARD_H


#define _MVML         SGUI(KC_LEFT)
#define _MVMR        SGUI(KC_RGHT)
#define _WDL         LCTL(KC_LEFT)
#define _WDR        LCTL(KC_RGHT)
#define _TBL         LCTL(KC_PGUP)
#define _TBR        LCTL(KC_PGDN)
#define _MWL         LGUI(KC_LEFT)
#define _MWU           LGUI(KC_UP)
#define _MWD         LGUI(KC_DOWN)
#define _MWR        LGUI(KC_RGHT)


#define _LMWL           LSFT(_MWL)
#define _LMWR           LSFT(_MWR)
#define _LMWU           LSFT(_MWU)
#define _LMWD           LSFT(_MWD)

#define _BASE           0
#define _WM             1
#define _LM             2 
#define _NUM            3
#define _MCRO           4

#define TAPPING_TOGGLE  2

enum my_keycodes {
    // Windows
    _NDES = SAFE_RANGE,
    _XDES,
    _LDES,
    _RDES,
    _SETL,
    _SETW,
    _SETG,
    _ML,

};

typedef union {
    uint32_t raw;
    struct {
        bool    linux :1;
        bool    gamer :1;
    };
} user_config_t;

user_config_t user_config;

bool CAPS = false;


bool process_record_user(uint16_t keycode, keyrecord_t *record);
void macro_check(uint16_t keycode, keyrecord_t *record);


/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */


const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[0] = LAYOUT_ortho_5x14(KC_ESC, KC_GRV, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_BSPC, KC_DEL, KC_EQL, KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_LBRC, KC_RBRC, KC_MINS, KC_CAPS, KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_SCLN, KC_QUOT, KC_BSLS, MO(4), KC_LSFT, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_RSFT, MO(4), TT(5), KC_LCTL, KC_LGUI, KC_LALT, _ML, KC_ENT, KC_ENT, KC_SPC, KC_SPC, _ML, KC_APP, KC_RGUI, KC_RCTL, TT(3)),
	[1] = LAYOUT_ortho_5x14(KC_NO, KC_TRNS, KC_F13, KC_F14, _NDES, _XDES, KC_NO, KC_INS, KC_PSCR, KC_SLCK, KC_PAUS, KC_NO, KC_TRNS, KC_NO, KC_NO, KC_NO, KC_NO, _LDES, _MVML, _MVMR, _RDES, _WDL, _TBL, _TBR, _WDR, KC_NO, KC_TRNS, KC_NO, KC_NO, KC_TRNS, KC_NO, _MWL, _MWU, _MWD, _MWR, KC_LEFT, KC_DOWN, KC_UP, KC_RGHT, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_HOME, KC_PGDN, KC_PGUP, KC_END, KC_NO, KC_TRNS, KC_NO, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS),
	[2] = LAYOUT_ortho_5x14(KC_NO, KC_TRNS, KC_F13, KC_F14, KC_NO, KC_NO, KC_NO, KC_INS, KC_PSCR, KC_SLCK, KC_PAUS, KC_NO, KC_TRNS, KC_NO, KC_NO, KC_TRNS, KC_NO, _LMWL, _LMWU, _LMWD, _LMWR, _WDL, _TBL, _TBR, _WDR, KC_NO, KC_TRNS, KC_NO, KC_NO, KC_NO, KC_NO, _MWL, _MWU, _MWD, _MWR, KC_LEFT, KC_DOWN, KC_UP, KC_RGHT, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_HOME, KC_PGDN, KC_PGUP, KC_END, KC_NO, KC_TRNS, KC_NO, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS),
	[3] = LAYOUT_ortho_5x14(KC_NO, KC_TRNS, KC_PSLS, KC_7, KC_8, KC_9, KC_NLCK, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_BSPC, KC_DEL, KC_NO, KC_TRNS, KC_PAST, KC_4, KC_5, KC_6, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_ENT, KC_PMNS, KC_1, KC_2, KC_3, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS, KC_PPLS, KC_0, KC_COMM, KC_DOT, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS, KC_NO, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS),
	[4] = LAYOUT_ortho_5x14(KC_MUTE, KC_NO, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, KC_VOLU, KC_NO, RGB_TOG, RGB_MOD, RGB_VAI, RGB_HUI, RGB_SAI, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_VOLD, KC_NO, KC_NO, RGB_RMOD, RGB_VAD, RGB_HUD, RGB_SAD, KC_NO, KC_NO, KC_NO, KC_NO, _SETW, _SETL, _SETG, KC_TRNS, KC_NO, KC_NO, KC_NO, KC_CALC, KC_NO, RESET, RESET, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS),
	[5] = LAYOUT_ortho_5x14(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_ACL0, KC_ACL1, KC_ACL2, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_MS_L, KC_MS_D, KC_MS_U, KC_MS_R, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_WH_L, KC_WH_D, KC_WH_U, KC_WH_R, KC_NO, KC_NO, KC_NO, KC_TRNS, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_BTN1, KC_BTN1, KC_BTN2, KC_BTN3, KC_NO, KC_NO, KC_NO)
};

bool process_record_user(uint16_t keycode, keyrecord_t *record) {


    if(record->event.pressed)
    {
        switch (keycode) {
            case _NDES:
                SEND_STRING(SS_LCTRL(SS_TAP(X_LALT)));
                register_code(KC_LCTRL);
                register_code(KC_LGUI);
                tap_code(KC_D);
                unregister_code(KC_LCTRL);
                unregister_code(KC_LGUI);
                break;
            case _XDES:
                SEND_STRING(SS_LCTRL(SS_TAP(X_LALT)));
                register_code(KC_LCTRL);
                register_code(KC_LGUI);
                tap_code(KC_F4);
                unregister_code(KC_LCTRL);
                unregister_code(KC_LGUI);

                break;
            case _LDES:
                SEND_STRING(SS_LCTRL(SS_TAP(X_LALT)));
                register_code(KC_LCTRL);
                register_code(KC_LGUI);
                tap_code(KC_LEFT);
                unregister_code(KC_LCTRL);
                unregister_code(KC_LGUI);

                break;
            case _RDES:
                SEND_STRING(SS_LCTRL(SS_TAP(X_LALT)));
                register_code(KC_LCTRL);
                register_code(KC_LGUI);
                tap_code(KC_RIGHT);
                unregister_code(KC_LCTRL);
                unregister_code(KC_LGUI);

                break;
            case _SETW:
                user_config.linux = false;
                eeconfig_update_user(user_config.raw);
                break;
            case _SETL:
                user_config.linux = true;
                eeconfig_update_user(user_config.raw);
                break;
            case _SETG:
                user_config.gamer = !user_config.gamer;
                eeconfig_update_user(user_config.raw);
                break;
        }

    }

    if (keycode == _ML) {
        if(record->event.pressed) {
            if (!user_config.linux) {
                layer_on(_WM); } else {
                    layer_on(_LM);
                }

        } else {
            if (!user_config.linux) {
                layer_off(_WM);
            } else {
                layer_off(_LM);
            }
        }
    }
    

    if (keycode == KC_ENTER) {
        if (!user_config.gamer) {
            return true;
        } else { 
            if(record->event.pressed) {
                register_code(KC_SPACE);}
            else { 
                unregister_code(KC_SPACE);} 
            return false;
        }
    }


    
    if (keycode == KC_ESC) {
        if (CAPS && record->event.pressed) {
            tap_code(KC_CAPS);}
    }


/*
    if (keycode == KC_SPACE) {
        if (!user_config.gamer) {
            return true;
        } else { 
            if(record->event.pressed) {
                register_code(KC_ENTER);

            } else { 
                unregister_code(KC_ENTER);} 
            return false;
        }
    }
*/



    /*
       if (layer_state_is(_MCRO)) {
       if(record->event.pressed) {
       register_code(KC_F24);
       } else {
       unregister_code(KC_F24);
       }
       }
       */
    return true;
}




void eeconfig_init_user(void) {  // EEPROM is getting reset!
    user_config.raw = 0;
    user_config.linux = false; // We want this enabled by default
    user_config.gamer = false; // We want this enabled by default
    eeconfig_update_user(user_config.raw); // Write default value to EEPROM now

}

// RGB LAYERS
const rgblight_segment_t PROGMEM my_capslock_layer[] = RGBLIGHT_LAYER_SEGMENTS(
        {7, 2, 0, 255, 120 }       // Light 2 LEDs, starting with LED 7
        );
const rgblight_segment_t PROGMEM my_layer1_layer[] = RGBLIGHT_LAYER_SEGMENTS(
        {6, 4, 0, 0, 120}
        );
const rgblight_segment_t PROGMEM my_layer2_layer[] = RGBLIGHT_LAYER_SEGMENTS(
        {0, 1, 100, 234, 150}
        );

const rgblight_segment_t* const PROGMEM my_rgb_layers[] = RGBLIGHT_LAYERS_LIST(
        my_capslock_layer,
        my_layer1_layer,    // Overrides caps lock layer
        my_layer2_layer     // Overrides other layers
        );



layer_state_t layer_state_set_user(layer_state_t state) {
    // Both layers will light up if both kb layers are active
    rgblight_set_layer_state(1, layer_state_cmp(state, 1) || layer_state_cmp(state, 2));
    rgblight_set_layer_state(2, user_config.gamer );
    rgblight_set();
    return state;
}





bool led_update_user(led_t led_state) {
    CAPS = led_state.caps_lock;
    rgblight_set_layer_state(0, led_state.caps_lock);
    rgblight_set();
    return true;
}

void keyboard_post_init_user(void) {
    // Read the user config from EEPROM
    user_config.raw = eeconfig_read_user();
    // Enable the LED layers
    rgblight_layers = my_rgb_layers;
}


